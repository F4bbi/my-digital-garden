---
{"dg-publish":true,"permalink":"/university-notes-in-italian/reti/5-il-livello-di-collegamento/","created":"2023-12-03T22:24:24.528+01:00","updated":"2023-12-03T22:43:17.041+01:00"}
---

# Capitolo 5: Livello collegamento
## Terminologia
Host e router a livello data link vengono definiti <font style="color:red">nodi</font> (di rete), ovvero qualunque oggetto sia dotato di un'interfaccia che gli permette di comunicare in rete. Il canale di comunicazione che collega due nodi adiacenti lungo un certo percorso si chiama <font style="color:red">collegamento</font> (<font style="color:red">link</font>) e possono essere di tipi diversi come ad esempio link cablati (cavo ethernet o in fibra), link wireless (wifi di casa e reti 4G, 5G) e LANs. Il pacchetto di livello 2 si chiama <font style="color:red">frame</font> ed incapsula un datagramma di livello 3. Il livello data link ha la funzione di trasportare un frame da un nodo a un altro nodo fisicamente adiacente.

Un percorso può contenere link di diversi tipi e quindi un datagramma, trasferito lungo questo percorso, attraversa quindi reti con protocolli di livello 2 differenti: per esempio sul primo link si ha Ethernet, sui link intermedi il Frame relay e sull'ultimo link 802.11. Ogni protocollo fornisce servizi diversi, come il controllo di errore che può esserci oppure no. Questo esempio ha un'analogia coni sistemi di trasporto, dove un viaggio da Princeton a Losanna può essere svolto in limousine per il tratto Princeton - JFK, in aereo per il tratto JFK - Ginevra e in treno per il tratto Ginevra - Losanna. In questo caso il datagramma è il turista, ogni tratto del viaggio è un link e la modalità di viaggio è il protocollo di livello data link. L'agenzia di viaggio è quindi l'algoritmo di routing, colui che ha gestito i salti da un luogo all'altro.

### Servizi di livello data link
#### Creazione di un frame di livello 2, accesso al link
- Incapsula un datagramma in un frame, aggiunge la protocol control informazion (header e trailer).
- Fornisce un meccanismo di accesso al canale se il mezzo di comunicazione è condiviso con altri dispositivi.
- Utilizza indirizzi di livello 2 (detti indirizzi “MAC”) negli header dei frame per identificare mittente e destinatario, ma sono diversi dagli indirizzi IP.

#### Consegna affidabile tra nodi adiacenti
- Sappiamo come ottenere questo servizio, per esempio utilizzando ARQ (automatic repeat query) per richiedere la ritrasmissione di pacchetti che non erano ancora arrivati.
- Poco usato su link a basso tasso di errore (per esempio le fibre ottiche), piuttosto si mantiene il protocollo semplice e si ritrasmette il pacchetto.
- Dato che i link wireless hanno alti tassi di errore, questo dipende dal protocollo utilizzato. Alcuni protocolli richiedono la ritrasmissione, mentre altri aspettano che la richiesta di ritrasmissione venga effettuata da protocolli di livello superiore.

Viene inserito un controllo di errore sia a livello 2 sia a livello 4 perché dato che è responsabilità del livello 4 il controllo di errore, non può fidarsi che tra i moltissimi link che attraverserà il pacchetto tutti effettueranno un controllo di errore a livello 2 e quindi per sicurezza lo fa anche lui.

#### Controllo di flusso
Adatta la velocità di trasmissione alle possibilità di trasmettitore e ricevitore, per esempio tra due schede ethernet con velocità diverse.

#### Rilevamento di errore
Ci saranno errori, soprattutto nei link senza fili, causati da attenuazione eccessiva del segnale, rumore ecc... Il ricevitore può quindi rilevare la presenza di errori e di conseguenza avvertire il mittente e/o scartare il pacchetto.

#### Correzione d’errore
Il ricevitore identifica e corregge gli errori sui bit senza però richiedere ritrasmissioni.

#### Half-duplex e full-duplex
In un collegamento full-duplex i nodi possono trasmettere e ricevere contemporaneamente (in uno half-duplex, no).

In un qualunque host di rete c'è una parte hardware che implementa il livello data link. Di solito il livello data link fa parte del firmware di un adattatore di rete (detto anche scheda di rete o network interface card, NIC) o su un chip. Scheda ethernet, scheda 802.11, chipset Ethernet. 
Il protocollo di livello 2 è talmente collegato al canale di comunicazione che di solito l'implementazione delle regole del protocollo di livello due e l'effettiva elettronica che va poi a trasmettere il pacchetto sul canale di comunicazione sono legate, dato che vengono implementate dallo stesso sistema. Infatti non esiste una scheda di rete che faccia mettere il protocollo ethernet su un canale Wi-Fi.
La scheda di rete o il chip che stanno sulla scheda madre, sono collegati direttamente al bus di sistema dell'host. Proprio per questo la comunicazione in rete avviene attraverso la combinazione di hardware, software e firmware.

![Pasted image 20221220092549.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220092549.png)

### Comunicazione tra adattatori di rete
#### Mittente
Incapsula un datagramma in un frame ed aggiunge bit ulteriori per controllo di errore, controllo di flusso, ecc...

#### Ricevente
Cerca eventuali errori, collabora al controllo di flusso, ecc... Estrae il datagramma e lo passa ai livelli superiori.

![Pasted image 20221220092903.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220092903.png)

## 5.1 Rilevamento e correzione di errori
Parleremo di <font style="color:red">EDC</font> (Error Detection and Correction) ed i bit che fanno parte di questa porzione di EDC sono ridondanti per fare in modo che sia possibile rilevare e correggere gli errori, grazie a queste informazioni in più che mi sono fornite dai bit.

**D** sono i dati protetti dal campo EDC, che non devono per forza essere i campi del payload ma possono essere anche campi dell'header (per esempio il checksum di TCP).

![Pasted image 20221220094214.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220094214.png)

In pratica in un datagramma ci sono dei dati che si vogliono proteggere (D) attraverso la ridondanza (EDC). Quando trasmettiamo in un link che può essere affetto da errori, si ricevono dei dati D' e una ridondanza ECD' che possono non essere gli stessi che erano stati trasmessi e, attraverso un algoritmo, si verifica che i bit ricevuti siano corretti. Se non sono corretti si rileva un errore e quindi il pacchetto o viene scartato o si richiede una ritrasmissione, ma se sono corretti viene estratto il datagramma e passato ai livelli superiori.

Il rilevamento di errore non è mai affidabile al 100%, perché il protocollo potrebbe non accorgersi di qualche errore, ma maggiore è la ridondanza (numero di bit del campo EDC), maggiore è la protezione (in generale).

### Controllo di parità
Supponiamo di avere un singolo bit di parità che quindi rileva errori singoli, per esempio nel caso in cui si vuole che il numero totale di bit a 1 nel frame sia pari. Se si riceve un pacchetto in cui l'ultimo bit è commutato in uno 0, il bit di parità è 1, ma il numero di bit a uno è pari, allora questo indica che il pacchetto è sbagliato.

![Pasted image 20221220095008.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220095008.png)

Se si aggiungesse il controllo di parità anche sulle colonne si potrebbe correggere l'errore. La parità su due dimensioni difatti rileva e corregge singoli errori sui bit. Questo però ha delle limitazioni, perché se ci fossero due cambiamenti su una stessa riga o su una stessa colonna non si potrebbe correggere l'errore.

![Pasted image 20221220095549.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220095549.png)

### Correzione di errori tramite ridondanza
Un'operazione detta "interleaving", che consiste nel riordino dei bit, fornisce anche una protezione contro errori a raffica (burst) per esempio:
- Messaggio: HELLO
- Ridondanza: HHH EEE LLL LLL OOO
- Interleaving: HEL LOH ELL OHE LLO
- Raffica di errori: HEL LOH E<font style="color:red">XX XXX</font> LLO
- De-interleaving: HH<font style="color:red">X</font> EE<font style="color:red">X</font> L<font style="color:red">X</font>L L<font style="color:red">X</font>L O<font style="color:red">X</font>O
- Scelta a maggioranza: HELLO

### Cyclic redundancy check (CRC)
Un algoritmo più efficiente per il rilevamento di errore è il CRC. Considera i bit di dati come un numero binario D, sceglie una sequenza di r+1 bit (detta generatore) e un numero G (noto sia al mittente sia al ricevente). L'obiettivo è di comporre il CRC (R) scegliendo r bit in modo che:
- I dati D siano esattamente divisibili per G (modulo 2) con resto R, o in altre parole che la concatenazione <D, R> sia divisibile per G.
- Il ricevente conosce G e quindi se divide <D,R> per G e il resto $\ne$ 0 allora significa che c'è un errore.
- Può rilevare anche errori a raffica, se ci sono meno di r bit errati consecutivi

Per concatenare D ed R basta calcolare <D,R> = ($D * 2^r$) XOR R

![Pasted image 20221220101856.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220101856.png)

#### Aritmetica intera modulo 2
La somma si calcola bit a bit, ma senza riporti, mentre la sottrazione si effettua sempre bit a bit, ma senza prestiti. L'operazione è la stessa, ovvero lo XOR.

![Pasted image 20221220105651.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220105651.png)

#### Calcolo di un CRC
Se vogliamo che D x $2^r$ XOR R sia un multiplo di G, serve che:
- D x $2^r$ XOR R  = nG

Aggiungiamo R (cioè effettuiamo XOR R) a entrambi i membri:
- D x $2^r$ = nG XOR R (effettuando due volte lo XOR si annulla l'operazione e quindi rimane solo D x $2^r$)

L'equazione mostra che se dividiamo D x $2^r$ per G, il resto è R. Come dire che se a = qb + r:
- quoziente (a/b) = q
- resto (a/b) = r

Quindi quello che si calcola per il CRC è:
- R = resto (D x $2^r$ / G)

![Pasted image 20221220110534.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220110534.png)

![Pasted image 20221220110612.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220110612.png)

## 5.2 Protocolli e tecnologie per l'accesso multiplo al canale
Ci possono essere diversi tipi di collegamento, per esempio ci sono collegamenti Punto-punto con protocollo PPP per il dial-up access oppure un collegamento punto-punto tra uno swtich Ethernet e un host.
Esistono anche canali condivisi, detti broadcast, dove il mezzo di trasmissione è condiviso. Es vecchie versioni di Ethernet, Hybrid fiber-coaxial (HFC) per TV e Internet, 802.11 wireless LAN.

![Pasted image 20221220111728.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220111728.png)

### Protocolli per il controllo dell'accesso multiplo
Questi protocolli servono per regolamentare l'accesso ad un canale broadcast condiviso, questo perché due o più trasmissioni simultanee che partono da nodi diversi possono creare interferenza. Se un nodo riceve due o più segnali nello stesso momento si verifica una collisione.
Il protocollo di accesso multiplo è un algoritmo distribuito che determina come i nodi condividano il canale, ovvero quando un nodo può trasmettere e quando no. In un canale broadcast condiviso gli “accordi” di trasmissione vengono presi comunicando sullo stesso canale usato per i dati. Nella maggioranza dei casi non c’è un canale esterno dedicato al coordinamento (“out-of-band” channel).

Un protocollo <font style="color:red">MAC</font> (**multiple access control**) ideale, quando si ha a disposizione un canale broadcast capace di supportare comunicazioni a R bit/s, vorrebbe che:
- Quando un nodo trasmette, possa farlo a velocità R
- Quando M nodi vogliono trasmettere, possano farlo ad un tasso medio pari a R/M
- Il sistema fosse completamente decentralizzato:
	- Nessun “centro stella” che coordina le trasmissioni degli altri
	- Nessuna sincronizzazione di clock
- .…e se possibile che fosse semplice

Tale protocollo MAC ideale non esiste perché ci sono delle limitazioni fisiche che non permettono di implementarlo, ma ci sono comunque dei protocolli che vanno bene a seconda delle condizioni. Verranno analizzate tre classi:

#### A ripartizione delle risorse di canale
- Dividono il canale in “sotto-canali” più piccolo (es. Slot temporali, sotto-frequenze, codici di spreading)
- Allocano ciascun sotto-canale a un nodo in modo esclusivo

#### Ad accesso casuale
- Il canale non viene suddiviso, si accetta che si verifichino collisioni
- Si cerca comunque di minimizzarle

#### A “turni” intelligenti
- I nodi accedono al canale a turno, ma i nodi con molti dati da trasmettere possono ottenere turni più lunghi

### 5.2.1 Protocolli a ripartizione delle risorse
#### TDMA: time division multiple access
Si accede al canale in "round". Ogni nodo ottiene uno slot di durata fissa in ogni round, dove la lunghezza è il tempo di trasmissione di un pacchetto. Gli slot inutilizzati rimangono liberi in ogni caso.
Per esempio in una LAN con 6 nodi, di cui il nodo 1, il nodo 3 e il nodo 4 hanno pacchetti da trasmettere, mentre gli slot 2, 5 e 6 rimangono vuoti. Nella terminologia inglese un round viene anche chiamato frame.
![Pasted image 20221220113602.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220113602.png)

#### FDMA: frequency division multiple access
Un altro modo di ripartire le risorse è quello di suddividere le frequenze a disposizione all'interno di un certo canale. Lo spettro del canale è suddiviso in "sotto-bande" e ad ogni stazione si assegna una sotto-banda. Quando una sotto-banda non viene usata per trasmettere, la risorsa rimane inutilizzata.
Per esempio in una LAN con 6 nodi, di cui il nodo 1, il nodo 3 e il nodo 4 hanno pacchetti da trasmettere, mentre le sotto-bande 2, 5 e 6 rimangono vuote.
Quindi se abbiamo un canale da 20 MHz e abbiamo 5 nodi, ognuno di essi avrà un canale da 4 MHz.
![Pasted image 20221220114138.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220114138.png)

#### CDMA: code-division multiple access
Con CDMA la ripartizione delle risorse avviene assegnando un “codice” diverso ad ogni nodo. Con codice si intende la sequenza di “chip” che commuta più rapidamente di quanto commutino i bit. In questo caso si ha a disposizione tutto il tempo e la frequenza a disposizione. Il codice serve per rendere più veloce la commutazione dei bit.
![Pasted image 20221220115747.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220115747.png)

Il codice commuta nel tempo di un chip, che è più veloce dei nostri bit, che invece commutano ogni 7 chip. In un bit ci stanno 7 chip. Questo perché il sistema è stato progettato così.
![Pasted image 20221220120120.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220120120.png)

Rifacendo lo XOR tra il Codice 1 e la sequenza Dati XOR Codice 1 si ottengono nuovamente i Dati, perché è stata annullata l'operazione di XOR iniziale.
![Pasted image 20221220120959.png](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220120959.png)

Ciò che otteniamo dallo XOR tra Dati XOR Codice 1 e un Codice 2 è rumore, che non è interpretabile. Questa sequenza potrebbe essere un dato di qualcun altro in XOR con il suo codice e che riceviamo noi. Potremmo invece ottenere qualcosa nel caso dell'esempio precedente.
![Pasted image 20221220121221.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221220121221.png)

Tutti i nodi possono trasmettere contemporaneamente su tutta la banda e per tutto il tempo, ma per via del modo fisico in cui si creano i segnali non possono trasmettere alla velocità massima.

### 5.2.2 Protocolli ad accesso casuale
Quando un nodo ha un pacchetto da trasmettere lo può trasmettere al data rate massimo, ovvero R. Non c’è coordinamento con gli altri nodi prima della trasmissione e se due o più nodi trasmettono contemporaneamente avviene una collisione. 
Un protocollo ad accesso casuale specifica:
- come (e se) rilevare le collisioni
- come (e se) recuperare uno stato di collisione (ad esempio, imponendo a ciascun nodo di riprovare dopo un ritardo casuale)

Alcuni esempi di protocolli ad accesso casuale sono:
- Slotted ALOHA
- ALHOA
- CSMA, CSMA/CD, CSMA/CA

#### Slotted ALOHA
Lo slotted aloha assume che: 
- tutti i pacchetti (frame) hanno la stessa lunghezza
- il tempo è suddiviso in slot, ciascuno lungo quanto un pacchetto
- i nodi possono trasmettere solo all’inizio di uno slot, ma possono trasmettere anche in tutti gli slot
- nodi sono sincronizzati in modo che tutti sanno quando inizia uno slot
- se 2 o più nodi trasmettono, tutti vedono la collisione

Quando un nodo ha qualcosa da inviare, lo invia nello slot immediatamente successivo e se non ci sono collisioni il nodo può trasmettere ancora nello slot seguente. Se invece c’è una collisione il nodo ritrasmette il pacchetto con probabilità p in ogni slot seguente finché non ha successo.

**Vantaggi**: Se un solo nodo è attivo, può usare il canale continuamente ed essendo decentralizzato serve solo sincronizzarsi sullo slot. Inoltre è molto semplice.

**Svantaggi**: Le collisioni sono probabili e sprecano risorse, gli slot potrebbero rimanere vuoti perché non c'è coordinamento e si potrebbe rilevare la collisione senza aspettare la fine di una trasmissione. Inoltre sincronizzarsi richiede coordinamento.

In questo esempio i 3 nodi trasmettono nel primo slot ed avviene una collisione. Nel secondo slot nessuno ha ritrasmesso e nel terzo slot ritrasmettono il nodo 1 e 2, creando una collisione. Nello slot quattro il trasmette unicamente il nodo 2 e quindi la trasmissione ha successo.
![Pasted image 20221221110323.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221110323.png)

##### Slotted ALOHA: efficienza
Assumiamo che tutti i pacchetti hanno la stessa dimensione. Chiamiamo G≥0 il traffico offerto (numero medio di pacchetti inviati  
sul canale da tutte le stazioni in uno slot, includento trasmissioni e ritrasmissioni). La probabilità che ci siano $k$ pacchetti da trasmettere in uno slot ha una distribuzione statistica di Poisson:
- $P[k]=\frac{G^{k}\cdot e^{-G}}{k!}$

Il throughput ideale di questo protocollo è 1 perché la condizione ideale è che in ogni slot venga inviato un pacchetto. Il throughput effettivamente ottenuto è la probabilità che si abbia una sola trasmissione: $P[k=1]=G\cdot e^{-G}$.
Per ottenere il valore di G che massimizza il throughput dobbiamo calcolare la derivata $\frac{dGe^{-G}}{dG}=0$, ottenendo $G^*=1$. Di conseguenza, sostituendo il valore di G, otteniamo un throughput massimo pari a $\frac{1}{e}\approx0.368$.

##### Altro esempio
Supponiamo ora di avere $N$ nodi e che ciascuno trasmetta in un certo slot con probabilità p. 
La probabilità che un nodo trasmetta con successo è $p(1-p)^{N-1}$.
La probabilità che un nodo qualunque abbia successo è $\binom{N}{1}p(1-p)^{N-1}=Np(1-p)^{N-1}$.
Troviamo il valore di p che massimizza $Np(1-p)^{N-1}$ e quindi facciamo la derivata $\frac{dNp(1-p)^{N-1}}{dp}=0\to p^*=\frac{1}{N}$.
Quindi $Np^*(1-p^*)^{N-1}=(1-\frac{1}{N})^{N-1}$.
Se abbiamo infiniti nodi $\lim_{N\rightarrow \infty} (1-\frac{1}{N})^{N-1}=e^{-1}\approx0.368$.

#### ALOHA puro (non slotted)
Questo ALOHA è ancora più semplice perché non c'è nessuna sincronizzazione e quando un frame arriva, viene trasmesso subito. La probabilità di collisione però aumenta perché un frame inviato a $t_0$ collide con altri frame inviati in $[t_0-1,t_0+1]$. In pratica un frame può collidere con altri due frame contemporaneamente perché non sanno che gli altri stanno trasmettendo.
![Pasted image 20221221115242.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221115242.png)

##### ALOHA puro: efficienza
Assumiamo che tutti i pacchetti abbiano la stessa dimensione e ci siano infiniti host. Chiamiamo $G\ge0$ il traffico offerto (numero medio di pacchetti inviati sul canale da tutte le stazioni in uno slot, includento trasmissioni e ritrasmissioni). La probabilità che ci siano $k$ pacchetti da trasmettere in uno slot ha una distribuzione statistica di Poisson:
- $P[k]=\frac{G^{k}\cdot e^{-G}}{k!}$

Il throughput è la probabilità che un solo frame venga trasmesso durante il periodo di vulnerabilità $[t_0-1,t_0+1]$.
La probabilità che un solo frame venga trasmesso al tempo $t$ é $P[k=1]=Ge^{-G}$.
La probabilità che non ci siano frame la cui trasmissione inizia nell’intervallo $[t_0-1,t_0]$ è $P[k=0]=e^{-G}$.
Il throughput è la probabilità che una trasmissione abbia successo: $P[k=1]\cdot P[k=0]=Ge^{-2G}$.
Il throughput massimo si ottiene facendo la derivata $\frac{dGe^{-2G}}{dG}=0$, ottenendo $G=\frac{1}{2}$. Sostituendo tale valore otteniamo un throughput massimo pari a $\frac{1}{2e}\approx0.184$, che risulta essere metà di quello dello slotted ALHOA perché il tempo di vulnerabilità di ALOHA puro è il doppio di slotted ALOHA.

![Pasted image 20221221120758.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221120758.png)
Sull'asse $x$ c'è il traffico offerto (G), mentre sull'asse $y$ c'è il throughput. Come si può notare lo slotted ALOHA arriva ad un massimo di 1 pacchetto per slot, che corrisponde ad un throughput massimo di 0.368, mentre il throughput massimo di ALOHA puro è di 0.184 e viene raggiunto per un traffico offerto più basso che è 0.5.

### 5.2.3 CSMA: carrier sense multiple access
“Carrier” (cioè “portante”) è un termine che si riferisce al segnale che trasporta l’informazione, in termini umani significa ascoltare questo carrier prima di parlare. Se il canale viene valutato vuoto si trasmette un intero frame, se il canale viene valutato occupato si ritarda la trasmissione.

#### Versioni CSMA
##### Non persistente (0-persistente)
Quando un nodo è pronto a mandare un frame
- Se il canale è vuoto trasmette
- Se il canale è occupato attende un tempo casuale molto più lungo del tempo di trasmissione, esaurito il quale ritenta

##### 1-persistente
Quando un nodo è pronto a mandare un frame
- Se il canale è vuoto trasmette
- Se il canale è occupato attende finché non si libera, dopodiché trasmette subito
Se si verifica una collisione, il nodo attende un tempo casuale <font style="color:red">backoff</font>, poi ritenta seguendo la stessa procedura

##### p-persistente
Quando un nodo è pronto a mandare un frame
- Se il canale è vuoto trasmette
- Se il canale è occupato 
	- Attende finché non si libera
	- Dopodiché
		- Con probabilità $p$ trasmette il frame
		- Con probabilità $1 – p$ attende un tempo casuale molto più lungo del tempo di trasmissione, poi ritenta

Se si verifica una collisione, il nodo attende un tempo casuale, poi ritenta seguendo la stessa procedura.

![Pasted image 20221221135134.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221135134.png)

#### CSMA: periodo di vulnerabilità
Il periodo di vulnerabilità dipende dal tempo di propagazione τ e dal tempo richiesto dall'harware per rilevare se il canale è occupato ($T_a$). Se un nodo trasmette ma il segnale non ha raggiunto tutti gli altri nodi, un altro nodo potrebbe iniziare a trasmettere ed il periodo di vulnerabilità è $T_v=$τ$+T_a$. In generale, CSMA si usa quando τ (tempo di propagazione) ≪ (molto minore) T (tempo di trasmissione). Questo perché è più probabile effettuare un accesso al canale e vedere che il canale è effettivamente occupato.
![Pasted image 20221221141027.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221141027.png)

#### CSMA: collisioni
Anche con il CSMA ci possono essere collisioni perché esiste un ritardo di propagazione e quindi due nodi potrebbero non rilevare in tempo i rispettivi segnali. La collisione spreca l’intero tempo di trasmissione, per cui la distanza (e quindi il tempo di propagazione) giocano il ruolo più importante nel determinare la probabilità di collisione.

##### CSMA/CD (collision detection)
Nel caso di CSMA, in reti cablate è possibile inserire un meccanismo di collision detection, ovvero un sistema che usa comunque il carrier sensing e se il canale è occupato posticipa le trasmissioni come nel normale CSMA. In aggiunta però permette di rilevare le collisioni entro breve, permettendo di interrompere le trasmissioni e di ridurre lo spreco di risorse di comunicazione (uso canale, energia). Il CD è facile nelle LAN cablate full-duplex perché la potenza del segnale ricevuto è confrontabile con quella del segnale trasmesso da un nodo. Risulta invece piuttosto difficile nelle reti wireless perché la potenza del segnale ricevuto è molto minore della potenza del segnale trasmesso. Un analogia è una persona che parla molto, ma che quando parlano altri si interrompe.

In questo esempio il PC2 inizia a trasmettere (giallo) e poco tempo dopo anche il PC4 inizia a farlo anche lui (arancione). In seguito avviene una collisione (giallo/arancione) ed i due host se ne accorgono, per cui inviano un segnale di abort (collision detect) che fa terminare la trasmissione anche agli altri nodi, oltre che a loro stessi, per evitare la continuazione di trasmissioni interferite. Questo segnale di solito è un pacchetto.
![Pasted image 20221221144359.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221221144359.png)

##### CSMA/CA (COLLISION AVOIDANCE)
Il CSMA con collision avoidance si usa quando non si possono rilevare le collisioni, tipico per tutte le LAN wireless, e inoltre il tempo di trasmissione $T$ ≪ τ$+T_a$. Utilizzare CSMA 1-persistente non funziona bene in una LAN wireless perché le collisioni sono più probabili e non si possono rilevare perché il canale è half-duplex. CA significa comportarsi come in un CSMA p-persistente, dove il parametro $p$ dovrebbe essere adattato alle condizioni di rete (traffico, numero di nodi, …).

### 5.2.4 Protocolli MAC a turni
#### Polling
Un nodo master “invita” gli altri nodi (“slave”) a trasmettere a turno (uno alla volta). Viene usato di solito se i dispositivi slave hanno poche risorse o poca “intelligenza”, ma i problemi che comporta sono:
- I messaggi di polling occupano il canale (overhead)
- Latenza elevata perché bisogna aspettare che il master assegni il turno ad ogni slave
- Single point of failure (master), se cade tutta la rete muore

![Pasted image 20221222084318.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222084318.png)

#### Token passing
Il diritto di trasmettere è rappresentato dal possesso di un token (“gettone”), il quale si passa sequenzialmente da un nodo all’altro. Il token è un pacchetto. I problemi però sono:
- Overhead  dovuto al token
- Latenza
- Single point of failure (token)

![Pasted image 20221222084505.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222084505.png)

### 5.2.5 IEEE 802 ed Ethernet
Questo gruppo di standard suppone che esista un protocollo di livello rete (es IP) e che sotto esista un insieme di protocolli che gestisca l'accesso al mezzo, oltre che la gestione dei segnali. Il Logical Link Control (LCC) si occupa di gestire il protocollo utilizzato, perché avendo accesso a più interfacce sa qual è il più adatto per comunicare in ogni tipo di rete. Ad esempio se si sceglie di utilizzare Ethernet per inviare il datagramma che viene da IP, il livello MAC (viola) costruisce il frame e dice all'hardware di rete (verde) di trasmettere questi bit, il quale li convertirà in segnali elettrici.

![Pasted image 20221222085712.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222085712.png)

#### Gruppo di standard IEEE 802
![Pasted image 20221222085739.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222085739.png)

### Ethernet
Ethernet fa parte dell'insieme di protocolli IEEE 802 ed è di fatto lo standard dominante nelle reti cablate. È stata la prima tecnologia LAN di uso massivo e di solito si fa risiedere tutto il protocollo in un singolo chip che supporta varie velocità (es., Broadcom BCM5761). Semplice ed economico ed in continuo miglioramento 10 Mbit/s $\to$ 10+ Gbit/s.
![Pasted image 20221222090414.png](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222090414.png)

È un protocollo basato su Carrier Sense Multiple Access con Collision Detection e un backoff esponenziale di 3 Mbit/s, quando effettuando l'accesso al canale ci si accorgeva che era occupato.
La procedura di standardizzazione è stata piuttosto complicata prima di riuscire a definire sia il mezzo fisico sia la struttura dei frame.
![Pasted image 20221222091556.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222091556.png)

La prima topologia di Ethernet era un bus, ovvero un cavo coassiale al quale si allacciano tutte le stazioni che possono potenzialmente ricevere da tutti il segnale.
![Pasted image 20221222091859.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222091859.png)

##### Transceiver Ethernet (10Base5)
![Pasted image 20221222092035.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222092035.png)

##### Transceiver Ethernet (10Base-2)
![Pasted image 20221222092136.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222092136.png)

L'idea iniziale che fece decollare Ethernet fu l'hub, ovvero una scatoletta alla quale venivano collegati tutti i nodi e che aveva il compito di redistribuire il segnale. Dal punto di vista dei segnali non cambiava nulla, ma rendeva più semplice risolvere i problemi in caso di rottura di un collegamento.
![Pasted image 20221222092641.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222092641.png)

Prima venivano utilizzati dei cavi coassiali, ma poi furono introdotti i doppini incrociati (unshielded, shielded, foiled, ...) che risolvevano molti problemi di gestione e installazione, permettendo di eliminare il "tubo giallo". Da qui in poi, il mercato di Ethernet decolla veramente.
![Pasted image 20221222092939.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222092939.png)

Assieme al doppino incrociato venne anche il suo connettore rj45.
![Pasted image 20221222093027.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222093027.png)

#### Struttura del frame Ethernet
La scheda di rete del mittente incapsula un datagramma di IP (o di un altro protocollo di rete) in un frame Ethernet, all'interno del campo dati.

##### Preambolo
- 7 bytes 10101010 seguiti da un byte 10101011 che si usa per sincronizzare il clock del ricevitore e del trasmettitore, per fargli capire quando i bit devono essere letti.

##### Indirizzi
- 6 byte per gli indirizzi MAC (livello 2) di sorgente e destinazione
- Se la scheda di rete riceve un frame diretto a sé, o diretto a un indirizzo broadcast (es. i pacchetti ARP), passa il payload del frame ai protocolli di livello rete, altrimenti scarta il frame.
- L'indirizzo di destinazione viene prima di quello sorgente perché rende lo switching più veloce.

##### Lunghezza o Tipo
Se il numero è minore o uguale a 1536 indica la lunghezza del frame, altrimenti indica il tipo di datagramma contenuto all'interno del campo dati, ovvero il protocollo di livello superiore (tipicamente IP, ma ce ne possono essere altri, es., Novell IPX, AppleTalk).

##### CRC: cyclic redundancy check
Se si rilevano errori, il frame viene scartato (no ARQ). Viene per ultimo perché è un controllo di errore che protegge tutto il frame, ma anche perché uno switch potrebbe calcolare il proprio CRC di quel frame mentre riceve quello del mittente.

![Pasted image 20221222093235.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222093235.png)

#### Come funziona ethernet

##### Connectionless
Nessuno scambio di messaggi di controllo tra le interfacce di rete di mittente e destinatario.

##### Non affidabile
- Non si usano ACK/NACK per recuperare frame persi tramite ritrasmissioni.
- Non si usano codici a correzione di errore, ma solo CRC e quindi i dati nel payload del frame si recuperano solo se un protocollo di livello più alto (es. TCP) implementa controllo di errore.

Il protocollo MAC di Ethernet è CSMA/CD "unslotted", quindi se ci sono collisioni entro in un operazione di backoff binario esponenziale. 
- Alla prima collisione di un frame si attende un tempo scelto a caso tra $t=0$ e $t=T$ (solo uno dei due, no valori intermedi), $T$ è noto (es. 50 ms).
- Ad ogni altra collisione dello stesso frame, si raddoppia $T$ e si ripete.
- IEEE 802.3: al massimo, si raddoppia 7 volte per evitare di avere stazioni con ritardi eccessivamente lunghi.

#### Algoritmo CSMA/CD in Ethernet
1. La scheda di rete riceve un datagramma dal livello di rete e lo incapsula in un frame.
2. Se una scheda di rete vede il canale libero, comincia a trasmettere; se lo vede occupato, attende finché non è libero e poi trasmette.
3. Se la trasmissione termina senza rilevare altre trasmissioni, la scheda ritiene di aver trasmesso con successo il frame.
4. Altrimenti, se la scheda rileva una collisione, trasmette un segnale di “abort”.
5. Con ogni collisione, la scheda sceglie a caso il backoff tra il valore 0 e il valore $(2^k-1)T$, $k\leq7$, dove $T$ è il tempo necessario a trasmettere 512 bit.

Lo standard 802.3 presenta molti standard Ethernet differenti, il protocollo MAC e formato del frame sono comuni, ma nei livelli fisici sono presenti diverse velocità di trasmissione (2 Mbit/s, 10 Mbit/s, 100 Mbit/s, 1 Gbit/s, 10 Gbit/s, 40 Gbit/s) e diversi mezzi fisici (cavi a doppini incrociati, fibra ottica, ...). A livello data link c'è uno schema di negoziazione che riconosce il mezzo di trasmissione e la velocità massima alla quale si può procedere e li imposta automaticamente.
![Pasted image 20221222110307.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222110307.png)

#### Evoluzione di Ethernet
Fast Ethernet
- 100 Mbit/s
- Funziona sia con gli switch sia con un canale condiviso e CSMA/CD

Gigabit Ethernet
- 1 and 10 Gbit/s
- Solo reti con switch

40/100 Gigabit Ethernet
- 40 and 100 Gbit/s
- Solo reti con switch
- Principalmente su fibra ottica
	- Fino a 40 km di distanza

## 5.3 Ethernet switching
### 5.3.1 Backward learning
L'Hub è un ripetitore di livello 1, mentre lo Switch è un dispositivo di livello 2 (data link) che ha un ruolo più attivo:
- Riceve, memorizza e inoltra i frame Ethernet
- Per fare ciò, esamina il MAC address di destinazione dei frame che arrivano e li inoltra selettivamente su uno o più link collegati. Se necessario, ricorre a CSMA/CD per accedere al canale.

È trasparente agli host che non sanno (nè hanno bisogno di sapere) se sono collegati a uno switch. Inoltre ha delle funzioni di plug-and-play, riescono ad apprendere automaticamente com'è fatta la connessione di rete ed anche dove inoltrare i frame che arrivano per raggiungere il destinatario corretto. Non c’è bisogno di configurare esplicitamente gli switch per nessuna operazione di base.

#### Ethernet e domini di collisione
##### Topologia a bus
Tutti i nodi sono nello stesso dominio di collisione, ovvero chiunque può potenzialmente collidere con chiunque altro.

##### Topologia a stella
La prevalente al giorno d’oggi:
- Se il centro stella è un hub (ripetitore layer-1): stesso dominio di collisione
- Se il centro stella è uno switch (layer-2): diverso dominio di collisione

![Pasted image 20221222113431.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222113431.png)

#### Switch
In una rete “switched”, ogni host ha un canale dedicato per comunicare con lo switch. Si usa il protocollo Ethernet su ciascun link, ma gli unici nodi a usarlo sono l’host e la porta dello switch, quindi non ci sono collisioni e c'è comunicazione full duplex. Ogni link è un dominio di collisione a parte e quindi A e A’ possono comunicare insieme a B e B’, senza collidere.
![Pasted image 20221222113607.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222113607.png)

Lo switch, per sapere che A’ è raggiungibile tramite l’interfaccia 4 e B’ tramite la 5, mantiene una tabella:
![Pasted image 20221222113953.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222113953.png)

La tabella viene mantenuta con autoapprendimento. Ogni volta che riceve un frame da una porta, legge l'indirizzo MAC ed assocerà tale indirizzo alla quella porta. Man mano che si ricevono i frame si aggiornano le corrispondenze nella tabella, cancellando le righe vecchie.

##### Autoapprendimento
Nell'autoapprendimento (Backward learning) lo switch impara quali host possono essere raggiunti attraverso ogni interfaccia ed alla ricezione di un frame, si annota la porta da cui proviene e l’indirizzo MAC dell’host.
![Pasted image 20221222114615.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222114615.png) ![Pasted image 20221222114628.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222114628.png)

All'inizio la tabella è vuota e viene inserito solamente A per esempio. Quando si riceve un frame si aggiorna la tabella e si inoltra il frame.
- Se si trova una riga nella tabella che indica come raggiungere la destinazione del frame, se la destinazione si trova su una porta diversa da quella del mittente inoltra il frame, altrimenti lo scarta. Se per esempio E deve mandare un messaggio ad F utilizzeranno l'hub e quindi lo switch vedrà ma scarterà il frame.

- Se non c’è una riga nella tabella viene fatto il flooding (broadcast) del frame su tutte le interfacce (eccetto quella di arrivo).

![Pasted image 20221222115018.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222115018.png)

Un altro esempio è che la porta di destinazione per A' è sconosciuta, quindi lo switch si segna che A è raggiungibile dall'interfaccia 1 ed invia il pacchetto in flooding. Se un giorno A' risponderà inviando un pacchetto, allora lo switch potrà capire che lo si può raggiungere mediante l'interfaccia 4. In questo caso, dato che il pacchetto è indirizzato ad A che è presente nella tabella, lo si può inoltrare direttamente in unicast. Il TTL serve ad eliminare una entry della tabella se per molto tempo non la aggiorno (magari A' si sconnette).
![Pasted image 20221222171555.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222171555.png) ![Pasted image 20221222171603.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222171603.png)

##### Caso con switch multipli
Gli switch apprendono automaticamente anche quando sono connessi in topologie più complesse. Se per esempio A vuole trasmettere a G, attraverso l'autoapprendimento gli switch sapranno a quali porte inviare i frame, esattamente come nel caso di un solo switch.
![Pasted image 20221222172254.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222172254.png)

Questo è come funziona una rete istituzionale, in questo caso semplice.
![Pasted image 20221222172510.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222172510.png)

#### Switch, router e hub
##### Store-and-forward
- Router: dispositivi di livello di rete che esaminano gli header dei datagrammi
- Switch: dispositivi di livello data link che esaminano gli header dei frame
- Hub : puri ripetitori di segnale

##### Tabelle di inoltro
- Router: riempiono le tabelle usando algoritmi di routing, indirizzi di rete (es. IP)
- Switch: apprendono le tabelle di inoltro usando il flooding e i MAC address (livello 2)
- Hub: nulla

![Pasted image 20221222172944.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222172944.png)

#### Switch collegati ad anello (loop)
Se si collegano degli switch ad anello, quando verranno tutti fatti partire assieme tutte le tabelle degli switch saranno vuote. A invia un pacchetto a C, ma lo Switch 1 non sa dove sia C, quindi si annota che A è raggiungibile dalla porta 1 e manda i pacchetti in flooding. Nemmeno lo Switch 2 sa dove sia C, si annota che A è raggiungibile dalla porta 1 e quindi anche lui manda i pacchetti in flooding. Lo Switch 3 riceve frame sia da 1 sia da 2, aggiorna la sua tabella su come raggiungere A (magari da due percorsi diversi) ma non sa dove sia C e quindi anche lui manda i pacchetti in flooding. Questo porta ad un continuo refresh dei TTL che porterebbe i frame a circolare continuamente nell’anello.

![Pasted image 20221222173824.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222173824.png)

Questi loop tra switch saturano in fretta la capacità dei link e sovraccaricano gli apparati. Sono anche facili da creare perché basta collegare due porte di uno switch alla stessa LAN. Dato che i loop non sono da rimuovere perché forniscono ridondanza, quindi robustezza contro la rottura di qualche link, rompere fisicamente il loop (es., disconnettere qualche cavo) non è la strategia migliore. Un'idea migliore e usare una topologia logica più efficiente di quella fisica, ovvero STP (spanning tree protocol).

### 5.3.2 Spanning tree protocol (STP)
Per utilizzare un STP bisogna che si sia la formazione dell’albero automatica e un adattamento dinamico.
Tutti gli switch hanno un unico identificatore da 64 bit così formato:
- I primi 16 bit sono impostati dall’amministratore di rete
- Gli ultimi 48 bit sono il MAC address dello switch (impostato di fabbrica)

STP costruisce un albero con radice nello switch che ha l’ID più basso, quindi lo si può scegliere in maniera strategica. Dato che i bit più significativi sono configurabili, l’amministratore può scegliere dove piazzare la radice:
- Per esempio vicino al router di bordo della LAN
- Oppure, noto il traffico, nella posizione che non eccede la capacità dei link

Per creare lo spanning tree sono stati disattivati i lik B3-B4 e B4-B4, che evitano i loop, ma che possono essere utilizzati se ce ne fosse il bisogno. Non si ha necessariamente il percorso più corto per ogni pacchetto.
![Pasted image 20221222174924.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222174924.png)

Gli switch si scambiano pacchetti di controllo chiamati <font style="color:red">Bridge Protocol Data Unit</font> (BPDU) che contengono l’ID del mittente e il costo del link. Quando lo switch A riceve un BPDU da B, controlla gli ID, e se quello di A è più piccolo, la porta di B verso A diventa radice dell’albero per B. Altrimenti, tra tutte le porte da cui si riceve una BPDU:
- La porta da cui A riceve la BPDU con il costo più basso diventa la radice dell’albero per A (diciamo che questa BPDU veniva da B)
- B diventa progenitore di A nell’albero
- A aggiorna il proprio costo a c = $COST_A$ + $COST_B$
- Le porte da cui A riceve una BPDU con costo > c diventano  «designated ports» (figli di A nell’albero)
- Le porte da cui A riceve una BPDU con costo = c diventano «blocked ports», perché sono altri potenziali progenitori di B, che creerebbero loop a livelli più alti dell’albero, se usate.

Le porte quindi possono raggiungere 3 stati:
![Pasted image 20221222181220.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222181220.png)
Le BPDU vengono inviate periodicamente per rilevare cambiamenti ed ogni nodo le invia solo alle «designated ports», mentre le porte «Blocked» non sono mai coinvolte nella trasmissione di BPDU.

#### Variazioni di STP
Le BPDU vengono re-inviate periodicamente. La radice invia la BPDU a tutte le sue porte «designated», mentre gli altri switch ricevono la BPDU e la inoltrano alle proprie porte «designated». L’ultima BPDU ricevuta «invecchia» ogni secondo e quando l’età supera un valore massimo, serve un cambio di topologia dell’albero. Il processo di formazione riparte quindi da zero e finché l’albero non converge, gli switch non inoltrano traffico.

#### Performance di STP
Se le connessioni sono di tipo 1000 Base-T e ogni nodo della topologia qui sotto genera 100 Mbit/s di traffico, è meglio posizionare la radice dell’albero su B1 perché ogni link può potenzialmente trasportare 300 Mbit/s di traffico (3 quadrati in ogni nodo). Se B4 dovesse comunicare con B5, che è la radice, il link B3-B5 trasporterebbe 1200 Mbit/s di traffico che è superiore alla sua capacità massima.
![Pasted image 20221222181901.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222181901.png)

### 5.3.3 Domini di broadcast e di collisione
#### Dominio di collisione
Parte della rete in cui, se due nodi trasmettono contemporaneamente, si verifica una collisione.

#### Dominio di broadcast
Parte della rete che può essere raggiunta attraverso un messaggio di broadcast di livello 2. I nodi collegati alla stessa infrastruttura di livello 2 sono parte dello stesso dominio di broadcast.

![Pasted image 20221222182802.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222182802.png)

In questo esempio, se viene mandato un messaggio di broadcast di livello 2 non oltrepasserebbe il router perché si fermerebbe sulla sua interfaccia.
![Pasted image 20221222182943.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222182943.png)

![Pasted image 20221222183239.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222183239.png) ![Pasted image 20221222183244.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222183244.png)

### 5.3.4 VLAN
Ci sono molti buoni motivi per ripartire gruppi di host su LAN diverse, anche quando questi sono connessi alla stessa infrastruttura di rete.
- Separazione di intenti
	- Una LAN potrebbe contenere tutti i server esposti verso l’esterno (web, mail, database, etc.)
	- Una LAN diversa potrebbe essere riservata alle informazioni sensibili (es. database delle Risorse Umane con profili dei dipendenti) ed essere inaccessibile da fuori
- Separazione del carico
	- Esperimenti sulla rete potrebbero generare traffico incontrollato e saturare la LAN
- Separare i domini di broadcast
	- LAN più grandi diffondono i messaggi di broadcast su molti più link (inefficiente, meglio mantenere la località)

In passato avveniva una connessione e disconnessione di cavi dagli switch che però portava ad un problema, ovvero cambiamenti continui in una rete. Il tecnico dovrebbe passare molto tempo a cambiare i cablaggi, spostare host da un’area all’altra, sostituire gli switch che hanno finito le porte con switch più grandi (e più costosi). In alcuni casi, gli apparati di rete sono lontani o irraggiungibili e quindi è molto meglio gestire queste situazioni via software invece che «fisicamente». La soluzione sono le <font style="color:red">Virtual LANs</font> (VLANs).

#### Virtual LAN (VLAN)
Le VLAN non sono altro che un insieme di porte di uno o più switch di rete. Solitamente uno switch può supportare VLAN multiple, ma non tutti gli switch supportano le VLAN. Gli switch eseguono un processo di backward learning indipendente per ogni VLAN. Con il broadcast inviano i frame, o i frame per cui non esiste una riga nella tabella di inoltro, solo alle porte che fanno parte della stessa VLAN del mittente.

In questo esempio ci sono 3 VLAN, con nodi connessi a switch diversi. L’etichetta $k$ su una porta indica che lo switch inoltra su quella porta il traffico della VLAN $k$.
![Pasted image 20221222184404.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222184404.png)

Se il nuovo terminale Z deve essere allacciato alla VLAN2 e se W deve essere allacciato alla VLAN3, i due link evidenziati devono trasportare il traffico di diverse VLAN. Proprio per questo le porte corrispondenti vengono configurate in «trunk», ovvero porte abilitate a inoltrare tutto il traffico VLAN, a meno che una configurazione più avanzata non preveda diversamente.
![Pasted image 20221222184713.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222184713.png)

#### VLAN con switch multipli
Lo standard Ethernet 802.3 non prevedeva VLAN, ma finché le VLAN coinvolgono un solo switch, non è necessario cambiare lo standard. Se invece le VLAN si estendono su switch multipli, gli switch devono conoscere la VLAN per tutti i frame che gestiscono e quindi serve l’etichetta che specifica il VLAN ID. Il problema è che non c’erano bit disponibili a questo scopo nel formato dei frame Ethernet e quindi venne creato un protocollo specifico, l'802.1Q che estende l'802.3 con delle osservazioni chiave.
Solo gli switch devono conoscere le VLAN associate alle porte, mentre gli host non hanno bisogno di saperlo e quindi non c’è bisogno di cestinare tutte le schede di rete degli host. Basta quindi sostituire gli switch con quelli che permetteranno una configurazione software delle VLAN.

![Pasted image 20221222185510.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222185510.png)

A valle di questa discussione, nel 1998 il comitato IEEE 802.1Q fece l’impensabile e cambiò lo standard Ethernet, inserendo nel campo Length il valore esadecimale 0x8100 che indica che si sta utilizzando una VLAN. Quando ciò accade si sa che il campo successivo è formato da una priorità, un CFI e un VLAN Identifier (ovvero l'etichetta 1, 2, 3, ...). I campi Pri e CFI però non avevano nulla a che fare con le VLAN, perché:
- Pri indica la priorità del frame ed aiuta a implementare politiche di qualità del servizio
- CFI (Canonical Format Indicator) inizialmente specificava se l’ordine dei byte era big endian o little endian, ma poi tutta la rete si decise che dovesse essere big endian e quindi fu usato in 802.5 (token ring).

![Pasted image 20221222190456.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221222190456.png)

Non c’è bisogno che gli host supportino le VLAN perché se necessario, gli switch possono manipolare i frame per aggiungere o togliere i campi relativi alle VLAN. Una porta può quindi accettare frame con e senza tag, ma anche frame con tag diversi. Un host che usa VLAN può inviare frame con ID diversi, ad esempio: 
- Un ID per il traffico dati
- Un ID (eventualmente con priorità più alta) per traffico VoIP

Se un frame 802.1Q (con campi VLAN) arriva ad uno switch che non supporta le VLAN, nel caso peggiore lo switch non riconosce il frame e lo scarta. Nel caso migliore lo switch non supporta le VLAN ma conosce lo standard (tipico per switch recenti) e quindi lo switch inoltra comunque il frame secondo la propria tabella di inoltro, ignorando i campi VLAN.

## 5.4 IEEE 802.11 WiFi
### 5.4.1 Terminologia e architettura
#### Elementi di una rete wireless
![Pasted image 20221223091858.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223091858.png) ![Pasted image 20221223091941.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223091941.png) ![Pasted image 20221223092556.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223092556.png) 
![Pasted image 20221223092748.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223092748.png) ![Pasted image 20221223093048.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223093048.png)

#### Tassonomia di una rete wireless
![Pasted image 20221223093501.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223093501.png)

#### Wireless LAN IEEE 802.11
802.11b
- 2.4-5.8 GHz (spettro libero da licenze, ISM)
- Fino ad 11 Mbit/s
- Le trasmissioni avvengono come in un CDMA, ma tutti i nodi usano lo stesso codice (dà comunque un po’ di robustezza contro l’interferenza)

802.11a
- 5-6 GHz range
- Fino a 54 Mb/s

802.11g
- 2.4-5.8 GHz
- Fino a 54 Mb/s

802.11n: antenne multiple
- 2.4-5.8 GHz range
- Fino a 600 Mbit/s per 4 flussi radio contemporanei (150 Mbit/s per stazione)

802.11ac: multiple antennas
- Fino a 6.9 Gbit/s per 8 flussi radio (866 Mbit/s per stazione)

802.11ax (WiFi 6)
- Fino a 11 Gbit/s per 8 flussi radio (1375 Mbit/s per stazione)

#### Architettura di riferimento per una WLAN
![Pasted image 20221223101628.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223101628.png)

Un <font style="color:red">Basic Service Set</font> (BSS) è un insieme di STA che usano lo stesso protocollo MAC e competono per l’accesso allo stesso canale radio condiviso. Sì può immaginare come una cella in una rete cellulare. Un BSS può essere isolato o connesso a un sistema di distribuzione attraverso un AP, il quale funziona come uno switch. I protocolli MAC possono essere completamente distribuiti o controllati centralmente dall’AP. Un ESS (più BSS interconnessi da un sistema di distribuzione) appare come una sola LAN logica alle STA.

Come si può notare, l'AP ha due classi di MAC, una per la parte wireless ed una per la parte cablata. Il LLC gestisce il transito da un protocollo all'altro, perché potrebbe essere diverso sia il formato del frame che la MTU. 
![Pasted image 20221223105616.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223105616.png)

#### 802.11
Lo spettro di frequenze da 2,4 GHz a 2,485 GHz suddiviso in 11 canali (fino a 14 in certi stati).
L‘amministratore dell’AP sceglie la frequenza usata dall’AP e ci può essere interferenza se più AP vicini scelgono lo stesso canale (anche se impostate la “selezione automatica”). Una volta che l'AP è pronto con il suo canale, l'Host si deve “associare” con un AP. Questo viene fatto ascoltando su tutti i canali disponibili alla ricerca di frame speciali chiamati “beacon”, che contengono il nome di rete (service set ID, SSID) e l’indirizzo MAC dell’AP. Gli host scelgono a quale AP associarsi e potrebbero anche doversi autenticare. Quando si sono connessi hanno bisogno di un indirizzo IP e di solito usano DHCP per ottenere un indirizzo IP della stessa sottorete di cui fa parte l’AP. Ci sono due modalità che si possono utilizzare:

##### Scansione passiva
L’AP invia i beacon, H1 invia una richiesta di associazione all’AP scelto e l’AP risponde con una conferma alla richiesta di H1.
![Pasted image 20221223115238.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223115238.png)

##### Scansione attiva
H1 invia a tutti i vicini un frame di “probe request”, gli AP rispondono con un “probe response” a cui seguono richiesta e conferma di associazione.
![Pasted image 20221223115248.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223115248.png)

I collegamenti wireless hanno molte differenze chiave rispetto ai collegamenti cablati:
- Meno potenza del segnale ricevuto perché i segnali radio si attenuano fortemente mentre si propagano e quindi la qualità del segnale è inversamente proporzionale al quadrato della distanza.
- Interferenza da altre fonti radio: le frequenze degli standard WiFi (esempio: 2,4 GHz) sono usate anche da altri dispositivi (telefoni, forni a microonde), ma anche altri oggetti (es., i motori) creano disturbi
- Propagazione “multipath”: il segnale radio si riflette su oggetti e superfici, creando copie che raggiungono il destinatario con ritardi leggermente diversi

Nel complesso la comunicazione wireless è più difficile dal punto di vista fisico, anche su un semplice collegamento punto-punto, rispetto ad una rete cablata.
Per capire come si propaga un’onda radio, immaginate che l’antenna sia un punto e che da lì si estenda una sfera di raggio crescente. La potenza del segnale, inizialmente concentrata sull’antenna, si deve distribuire su sfere sempre più grandi (la cui superficie cresce come r2). L’attenuazione segue quindi una legge quadratica:
- $P_{rx} = k \cdot P_{tx} / d^2$
- $d$ è la distanza (il raggio della sfera)
- $k$ è una costante che conteggia altri fattori di attenuazione, di solito è < 1

Un’antenna non può trasmettere e ricevere contemporaneamente. Se pensiamo ad un AP con 2 antenne, un’antenna riceve contemporaneamente da una STA disposta a 10 m dall’AP e dall’altra antenna a 10 cm. Il rapporto tra le potenze ricevute: $P_{rx}$ (10 cm) / $P_{rx}$ (10 m) = 10 000. Quindi il segnale che proviene da 10 m si attenua 10 000 volte di più rispetto a quello che proviene da 10 cm, per cui non si è in grado di capire se effettivamente è avvenuta una collisione.

### 5.4.2 MAC 802.11
Per ovviare a questo problema si utilizza il Collision Avoidance (CA).
Le STA (stazioni) che hanno dati da trasmettere si contendono l’accesso al canale radio. Una STA ripete la contesa ogni volta che deve trasmettere dati. In alcune versioni più avanzate di 802.11 (es., 802.11n/ac) si può concedere il canale ad una STA per un periodo di tempo più lungo di un frame, chiamato TXOP. Questo permette al trasmettitore di inviare più frame senza contendere ogni volta.

#### Trasmettitore CSMA
![Pasted image 20221223121752.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223121752.png)

#### Ricevitore CSMA
![Pasted image 20221223122034.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122034.png)

#### Esempio completo
![Pasted image 20221223122318.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122318.png) ![Pasted image 20221223122446.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122446.png)
![Pasted image 20221223122656.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122656.png) ![Pasted image 20221223122818.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122818.png)
![Pasted image 20221223122923.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223122923.png)

![Pasted image 20221223123023.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223123023.png) ![Pasted image 20221223123158.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223123158.png)
![Pasted image 20221223123226.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223123226.png)

#### Problema del terminale nascosto
Il problema del terminale nascosto si presenta quando A e C sentono B, ma non si sentono a vicenda a causa di ostacoli interposti o a causa di pesante attenuazione.
![Pasted image 20221223123459.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223123459.png)
Dato che questo può causare collisioni sistematiche, l'obiettivo è evitare le collisioni su B mediante l'utilizzo di CSMA/CA con handshaking.

##### Messaggi RCS e CTS
L’handshake serve a prenotare esplicitamente il canale
- Il trasmettitore invia un messaggio Request To Send (RTS)
- Il ricevitore risponde con un messaggio Clear To Send (CTS)

Il CTS prenota il canale per il trasmettitore e notifica la trasmissione imminente ad altre STA (anche se nascoste). Questo mitiga il problema del terminale nascosto, ma al prezzo di un overhead maggiore.
Dato che gli RTS e i CTS sono messaggi brevi, se collidessero la collisione durerebbe meno ma comunque si sprecano meno risorse radio. Il problema che si introduce è quello del terminale esposto.

##### Scambio RTS-CTS

Se A e B scelgono lo stesso tempo di backoff per trasmettere l'RTS collidono, ma essendo messaggi piccoli dopo un timeout si riprova a trasmettere. Se la contesa viene vinta da A sarà lui a mandare l'RTS, il quale raggiunge l'access point che invierà a tutti un CTS che permetterà solamente ad A di comunicare. A quindi trasmetterà i suoi dati e poi l'AP manderà gli ACK. Questo libererà il canale e permetterà anche a tutte le stazioni bloccate di poter inviare i propri messaggi RTS. 
![Pasted image 20221223130110.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223130110.png)

Introducendo RTS-CTS si inserisce il problema del terminale esposto, questo nel caso si utilizzi lo stesso canale di comunicazione.
![Pasted image 20221223205743.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223205743.png)

#### Indirizzamento e frame 802.11
Come si può notare il payload è di 2312 byte, che sono di più dei 1500 byte concessi ad Ethernet, e proprio per questo c'è la necessità di un Link Layer Control (LLC).
![Pasted image 20221223210237.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223210237.png)

Il LLC dell'AP si prenderà l'indirizzo sorgente H1 e lo metterà nell'indirizzo sorgente del frame Ethernet, mentre l'indirizzo di destinazione del router R1 verrà messo nell'indirizzo destinazione del frame Ethernet.
![Pasted image 20221223211117.png|400](/img/user/%F0%9F%8E%93%20University%20notes%20(in%20Italian)/%F0%9F%8C%90%20Reti/_images/Pasted%20image%2020221223211117.png)