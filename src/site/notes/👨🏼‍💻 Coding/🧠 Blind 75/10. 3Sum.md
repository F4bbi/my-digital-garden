---
{"dg-publish":true,"permalink":"/coding/blind-75/10-3-sum/","created":"2023-08-11T22:58:12.456+02:00","updated":"2023-09-23T16:27:10.815+02:00"}
---

# 10. 3Sum
#leetcode/15
## Problem [üîó](https://leetcode.com/problems/3sum)
Given an integer array nums, return all the triplets¬†`[nums[i], nums[j], nums[k]]`¬†such that¬†`i != j`,¬†`i != k`, and¬†`j != k`, and¬†`nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example:**
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

## Solution
#### Solution in C++ using hash map
Using a hashmap, the idea is similar to [[üë®üèº‚Äçüíª Coding/üß† Blind 75/3. Two Sum\|3. Two Sum]].
1. Sort the input array
2. Store the index of the last occurrence of each number in a hashmap
3. Iterate through the array with a variable i, starting from index 0
4. Nested loop with a variable j, with j starting at i+1, and a variabile `required = -(nums[i] + nums[j])`
5. In the for loop, check if `hashMap.contains(required)`, and if true, add `{nums[i], nums[j], required}` to the output array
6. To avoid duplicates, we skip equal consecutive numbers

**Graphic explanation:**


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">

$<div class="markdown-embed-title">

# 700

</div>



==‚ö†  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ‚ö†==


# Text Elements
-1 ^M7aFcTrX

0 ^fu0KfxFG

2 ^bZarcjO1

-1 ^jw8cNnJS

Input: ^hozIbyJq

Operations: ^AepHEZNp

i = 0 ^KFCd5dmo

j = 1 ^pD1FybKY

Output: {{-1, -1, 2}, {-1, 0, 1}} ^3Pvjmjtz

1 ^o0DnBPO6

4 ^0lyWhOCp

1. Sort: ^UjbOtwmN

-1 ^GZFARgyn

-1 ^vEC1sxW1

1 ^fObUUe5e

2 ^a9pYjUYH

0 ^I5PlkLLw

4 ^WeD8RZ04

2. Store indexes
    in hashmap: ^Cl8WgoXH

{ -1:1, 0:2, 1:3, 2:4, 4:5 } ^E8iXn1Uw

3. Double for
    the array: ^hrA81KR4

-1 ^lhlY5Yuo

-1 ^2iobZs78

1 ^Q7dT4WBW

2 ^SjWJQ3SD

0 ^dyN5wlg9

4 ^TIfF1Ok3

i ^UaIOEq8x

j, next ^Ou0CRgIn

required ^Gk4J7ZhT

{-1, -1, 2} is pushed ^bt2fFGas

i = 0 ^yMQDq0So

j = 2 ^Fd952OLe

-1 ^9JaWIDmy

-1 ^E0X5Sxiz

1 ^135wtYZa

2 ^4K8PYhOf

0 ^9DqFn7Zo

4 ^r4lwZWs4

i ^0TkFYMlr

j, next ^OGTQJNEG

required ^dZW64W6H

{-1, 0, 1} is pushed ^PwsItxu7

i = 0 ^1IhyN16T

j = 3 ^0MSFPO5Q

-1 ^YLk0JvLS

-1 ^1qIL3dyY

1 ^31zi3ShB

2 ^d7XF45sk

0 ^LuOHZSsz

4 ^nOhGDDTT

i ^S1iGuLDL

required ^XuxOPYOL

j, next ^OAAz99q5

index of required < index of j
 ^BJeh0f5p

{-1, 1, 0} is NOT pushed ^TDde6G9X

Now i will be 2, not 1, because we do not want duplicates ^053s4hz7

i = 2 ^KKimB0FL

j = 3 ^m2jJzQoA

-1 ^nvF0OKac

-1 ^jKSuNUO6

1 ^w3zO4Hpk

2 ^78nyEAng

0 ^SxsKgZ1B

4 ^hZ5LdKag

i ^mUG8tPqn

j, next ^bOLcntfc

since i >= 0, the algorithm stops ^0mNSX8dg

skip, skip... ^PYgEfvpu



</div></div>


Here's the implementation.
```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
	sort(nums.begin(), nums.end());
	
	if(nums.size() < 3 || nums[0] > 0) return {};

	vector<vector<int>> ans;
	unordered_map<int, int> hashMap;
	int n = nums.size();

	//store the index of the last occurrence of each number in a hashmap
	for(int i = 0; i < n; i++)
		hashMap[nums[i]] = i;
	
	for(int i = 0; i < n && nums[i] <= 0; i++) {
		//to avoid duplicates, we skip equal consecutive numbers
		int next = hashMap[nums[i]];
		for(int j = i + 1; j < n; j++) {
			int required = -(nums[i] + nums[j]);
			//to avoid duplicates, we skip equal consecutive numbers
			int next = hashMap[nums[j]];
			//if required is in the array and its index > j
			if(hashMap.contains(required) && hashMap[required] > j)
				ans.push_back({nums[i], nums[j], required});
			j = next;
		}
		i  = next;
	}
	return ans;
}
```
- **Time complexity:** $O(n^2)$ (where _n_ is the size of the vector)
- **Space complexity:** $O(n)$ (we are storing all the input)

#### Solution in C++ using two pointers
Since the array is sorted, we can use a two pointers approach (three actually). One will be at the beginning of the array, the other at the end. In details:
1. Iterate through the array with a variable i, starting from index 0
2. If i is +ve, break there because we can't make it zero by searching after it
3. If number is getting repeated, ignore the lower loop and continue. This is for unique triplets. We want the last instance of the fixed number, if it is repeated.
4. Make two pointers start and end
5. Search between two pointers, just similar to binary search. We call `sum = nums[i] + nums[start] + nums[end`
6. If sum is -ve, means, we need more +ve numbers to make it 0, increment start
7. If sum is +ve, means, we need more -ve numbers to make it 0, decrement end
8. If sum is 0, that means we have found the required triplet, push it in answer vector
9. Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[start]] and num[end] respectively. Update the start and end with last occurences of low and high

**Graphic explanation:**


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">

$<div class="markdown-embed-title">

# 700

</div>



==‚ö†  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ‚ö†==


# Text Elements
-1 ^M7aFcTrX

0 ^fu0KfxFG

2 ^bZarcjO1

-1 ^jw8cNnJS

Input: ^hozIbyJq

Operations: ^AepHEZNp

i = 0 ^KFCd5dmo

j = 1 ^pD1FybKY

Output: {{-1, -1, 2}, {-1, 0, 1}} ^3Pvjmjtz

1 ^o0DnBPO6

4 ^0lyWhOCp

1. Sort: ^UjbOtwmN

-1 ^GZFARgyn

-1 ^vEC1sxW1

1 ^fObUUe5e

2 ^a9pYjUYH

0 ^I5PlkLLw

4 ^WeD8RZ04

2. Store indexes
    in hashmap: ^Cl8WgoXH

{ -1:1, 0:2, 1:3, 2:4, 4:5 } ^E8iXn1Uw

3. Double for
    the array: ^hrA81KR4

-1 ^lhlY5Yuo

-1 ^2iobZs78

1 ^Q7dT4WBW

2 ^SjWJQ3SD

0 ^dyN5wlg9

4 ^TIfF1Ok3

i ^UaIOEq8x

j, next ^Ou0CRgIn

required ^Gk4J7ZhT

{-1, -1, 2} is pushed ^bt2fFGas

i = 0 ^yMQDq0So

j = 2 ^Fd952OLe

-1 ^9JaWIDmy

-1 ^E0X5Sxiz

1 ^135wtYZa

2 ^4K8PYhOf

0 ^9DqFn7Zo

4 ^r4lwZWs4

i ^0TkFYMlr

j, next ^OGTQJNEG

required ^dZW64W6H

{-1, 0, 1} is pushed ^PwsItxu7

i = 0 ^1IhyN16T

j = 3 ^0MSFPO5Q

-1 ^YLk0JvLS

-1 ^1qIL3dyY

1 ^31zi3ShB

2 ^d7XF45sk

0 ^LuOHZSsz

4 ^nOhGDDTT

i ^S1iGuLDL

required ^XuxOPYOL

j, next ^OAAz99q5

index of required < index of j
 ^BJeh0f5p

{-1, 1, 0} is NOT pushed ^TDde6G9X

Now i will be 2, not 1, because we do not want duplicates ^053s4hz7

i = 2 ^KKimB0FL

j = 3 ^m2jJzQoA

-1 ^nvF0OKac

-1 ^jKSuNUO6

1 ^w3zO4Hpk

2 ^78nyEAng

0 ^SxsKgZ1B

4 ^hZ5LdKag

i ^mUG8tPqn

j, next ^bOLcntfc

since i >= 0, the algorithm stops ^0mNSX8dg

skip, skip... ^PYgEfvpu



</div></div>


Here's the implementation.
```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
	sort(nums.begin(), nums.end());
	
	if(nums.size() < 3 || nums[0] > 0) return {};

	vector<vector<int>> ans;
	
	int n = nums.size();
   
	for(int i = 0 ; i < n - 1 && nums[i] <= 0; i++) {
		int start = i + 1, end = n - 1;
		while(start < end) {
			if(nums[i] + nums[start] + nums[end] > 0)
				end--;
			else if(nums[i] + nums[start] + nums[end] < 0)
				start++;
			else {
				ans.push_back({nums[i], nums[start], nums[end]});
				int currStart = start;
				int currEnd = end;
				//to avoid duplicates, we skip equal consecutive numbers
				while(start < end && nums[start] == nums[currStart]) start++;
				while(start < end && nums[end] == nums[currEnd]) end--;
			}
		}
		//to avoid duplicates, we skip equal consecutive numbers
		while(i + 1 < n && nums[i] == nums[i + 1]) i++;
	}
	return ans;
}
```
- **Time complexity:** $O(n^2)$ (where _n_ is the size of the vector)
- **Space complexity:** $O(1)$