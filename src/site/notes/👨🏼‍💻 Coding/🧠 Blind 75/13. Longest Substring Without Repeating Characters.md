---
{"dg-publish":true,"permalink":"/coding/blind-75/13-longest-substring-without-repeating-characters/","created":"2023-09-28T23:50:16.873+02:00","updated":"2023-09-28T23:50:16.873+02:00"}
---

# 13. Longest Substring Without Repeating Characters
#leetcode/3
## Problem [ðŸ”—](https://leetcode.com/problems/longest-substring-without-repeating-characters)
Given a stringÂ `s`, find the length of theÂ longest substring without repeating characters.

**Example:**
```
Input: s = "abcabcbb"
Output: 3
```

## Solution
#### Solution in C++ using two pointers and a hashmap
The idea is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (`low`Â andÂ `high`) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.
Here's the process:
1. The map stores characters as keys and their indices as values.
3. We still maintain theÂ `low`Â andÂ `high`Â pointers and theÂ `maxSoFar`Â variable.
4. We iterate through the string using theÂ `high`Â pointer.
5. If the current character is not in the map or its index is less thanÂ `left`, it means it is a new unique character. Then. we update theÂ `map`Â with the character's index and update theÂ `maxSoFar`Â if necessary.
6. If the character is repeating within the current substring, we move theÂ `low`Â pointer to the next position after the last occurrence of the character.
7. We update the index of the current character in theÂ `map`Â and continue the iteration.
8. At the end, we return `maxSoFar`Â as the length of the longest substring without repeating characters.

```cpp
int lengthOfLongestSubstring(string s) {
	unordered_map<char, int> map;
	int maxHere = 0, maxSoFar = 0;
	for(int low = 0, high = 0; high < s.size(); high++) {
		char currChar = s[high];
		
		if(map.contains(currChar) && map[currChar] >= low)
			low = map[currChar] + 1;
		
		maxHere = high - low + 1;
		maxSoFar = max(maxSoFar, maxHere);
		map[currChar] = high;
	}
	return max(maxHere, maxSoFar);
}
```
- **Time complexity:** $O(n)$ (where _n_ is the size of the string)
- **Space complexity:** $O(n)$ (we are storing all the input)